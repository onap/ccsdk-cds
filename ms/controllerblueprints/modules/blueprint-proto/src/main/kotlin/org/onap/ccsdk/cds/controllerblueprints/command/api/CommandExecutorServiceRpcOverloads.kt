// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
@file:JvmName("-CommandExecutorServiceRpcOverloads")

package org.onap.ccsdk.cds.controllerblueprints.command.api

import com.github.marcoferrer.krotoplus.coroutines.client.clientCallUnary
import com.google.common.util.concurrent.ListenableFuture
import io.grpc.stub.StreamObserver
import kotlin.Unit
import kotlin.jvm.JvmName
import org.onap.ccsdk.cds.controllerblueprints.command.api.CommandExecutorServiceGrpc.CommandExecutorServiceBlockingStub
import org.onap.ccsdk.cds.controllerblueprints.command.api.CommandExecutorServiceGrpc.CommandExecutorServiceFutureStub
import org.onap.ccsdk.cds.controllerblueprints.command.api.CommandExecutorServiceGrpc.CommandExecutorServiceStub

inline fun CommandExecutorServiceStub.prepareEnv(responseObserver: StreamObserver<ExecutionOutput>,
        block: PrepareEnvInput.Builder.() -> Unit) {
    val request = PrepareEnvInput.newBuilder()
        .apply(block)
        .build()
    prepareEnv(request, responseObserver)
}

inline fun CommandExecutorServiceFutureStub.prepareEnv(block: PrepareEnvInput.Builder.() -> Unit):
        ListenableFuture<ExecutionOutput> {
    val request = PrepareEnvInput.newBuilder()
        .apply(block)
        .build()
    return prepareEnv(request)
}

inline fun CommandExecutorServiceBlockingStub.prepareEnv(block: PrepareEnvInput.Builder.() -> Unit):
        ExecutionOutput {
    val request = PrepareEnvInput.newBuilder()
        .apply(block)
        .build()
    return prepareEnv(request)
}

fun CommandExecutorServiceStub.prepareEnv(responseObserver: StreamObserver<ExecutionOutput>) {
    prepareEnv(PrepareEnvInput.getDefaultInstance(),responseObserver)
}

fun CommandExecutorServiceFutureStub.prepareEnv(): ListenableFuture<ExecutionOutput> =
        prepareEnv(PrepareEnvInput.getDefaultInstance())

fun CommandExecutorServiceBlockingStub.prepareEnv(): ExecutionOutput =
        prepareEnv(PrepareEnvInput.getDefaultInstance())

suspend fun CommandExecutorServiceStub.prepareEnv(request: PrepareEnvInput =
        PrepareEnvInput.getDefaultInstance()): ExecutionOutput = clientCallUnary(request,
        CommandExecutorServiceGrpc.getPrepareEnvMethod())

suspend inline fun CommandExecutorServiceStub.prepareEnv(block: PrepareEnvInput.Builder.() -> Unit):
        ExecutionOutput {
    val request = PrepareEnvInput.newBuilder()
        .apply(block)
        .build()
    return prepareEnv(request)
}

inline fun CommandExecutorServiceStub.executeCommand(responseObserver:
        StreamObserver<ExecutionOutput>, block: ExecutionInput.Builder.() -> Unit) {
    val request = ExecutionInput.newBuilder()
        .apply(block)
        .build()
    executeCommand(request, responseObserver)
}

inline fun CommandExecutorServiceFutureStub.executeCommand(block: ExecutionInput.Builder.() ->
        Unit): ListenableFuture<ExecutionOutput> {
    val request = ExecutionInput.newBuilder()
        .apply(block)
        .build()
    return executeCommand(request)
}

inline fun CommandExecutorServiceBlockingStub.executeCommand(block: ExecutionInput.Builder.() ->
        Unit): ExecutionOutput {
    val request = ExecutionInput.newBuilder()
        .apply(block)
        .build()
    return executeCommand(request)
}

fun CommandExecutorServiceStub.executeCommand(responseObserver: StreamObserver<ExecutionOutput>) {
    executeCommand(ExecutionInput.getDefaultInstance(),responseObserver)
}

fun CommandExecutorServiceFutureStub.executeCommand(): ListenableFuture<ExecutionOutput> =
        executeCommand(ExecutionInput.getDefaultInstance())

fun CommandExecutorServiceBlockingStub.executeCommand(): ExecutionOutput =
        executeCommand(ExecutionInput.getDefaultInstance())

suspend fun CommandExecutorServiceStub.executeCommand(request: ExecutionInput =
        ExecutionInput.getDefaultInstance()): ExecutionOutput = clientCallUnary(request,
        CommandExecutorServiceGrpc.getExecuteCommandMethod())

suspend inline fun CommandExecutorServiceStub.executeCommand(block: ExecutionInput.Builder.() ->
        Unit): ExecutionOutput {
    val request = ExecutionInput.newBuilder()
        .apply(block)
        .build()
    return executeCommand(request)
}
